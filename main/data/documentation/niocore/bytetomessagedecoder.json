{"metadata":{"title":"ByteToMessageDecoder","roleHeading":"Protocol","modules":[{"name":"NIOCore"}],"navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"role":"symbol","externalID":"s:7NIOCore20ByteToMessageDecoderP","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"symbolKind":"protocol"},"variants":[{"paths":["\/documentation\/niocore\/bytetomessagedecoder"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"kind":"symbol","primaryContentSections":[{"declarations":[{"platforms":["Linux"],"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"languages":["swift"]}],"kind":"declarations"},{"kind":"content","content":[{"level":3,"anchor":"Purpose","type":"heading","text":"Purpose"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" provides a simplified API for handling streams of incoming data that can be broken"},{"type":"text","text":" "},{"type":"text","text":"up into messages. This API boils down to two methods: "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":". These two methods, when"},{"type":"text","text":" "},{"type":"text","text":"implemented, will be used by a "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" paired with a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to decode the"},{"type":"text","text":" "},{"type":"text","text":"incoming byte stream into a sequence of messages."}],"type":"paragraph"},{"inlineContent":[{"text":"The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that","type":"text"},{"text":" ","type":"text"},{"text":"is often necessary when implementing parsers in a SwiftNIO ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":". A ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" ","type":"text"},{"text":"never needs to worry about how inbound bytes will be buffered, as ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" deals with that","type":"text"},{"text":" ","type":"text"},{"text":"automatically. A ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" also never needs to worry about memory exclusivity violations","type":"text"},{"text":" ","type":"text"},{"text":"that can occur when re-entrant ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" operations occur, as ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" will deal with","type":"text"},{"text":" ","type":"text"},{"text":"those as well.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"Implementing-ByteToMessageDecoder","type":"heading","text":"Implementing ByteToMessageDecoder"},{"inlineContent":[{"text":"A type that implements ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" may implement two methods: decode and decodeLast. Implementations","type":"text"},{"text":" ","type":"text"},{"text":"must implement decode: if they do not implement decodeLast, a default implementation will be used that","type":"text"},{"text":" ","type":"text"},{"text":"simply calls decode.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decode"},{"type":"text","text":" is the main decoding method, and is the one that will be called most often. "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" is invoked"},{"type":"text","text":" "},{"type":"text","text":"whenever data is received by the wrapping "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":". It is invoked with a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" containing"},{"type":"text","text":" "},{"type":"text","text":"all the received data (including any data previously buffered), as well as a "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" that can be"},{"type":"text","text":" "},{"type":"text","text":"used in the "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" function."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decode"},{"type":"text","text":" is called in a loop by the "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":". This loop continues until one of two cases occurs:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The input ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" has no more readable bytes (i.e. ","type":"text"},{"type":"codeVoice","code":".readableBytes == 0"},{"text":"); OR","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" method returns "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"text":"The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are","type":"text"},{"type":"text","text":" "},{"type":"text","text":"respected. It is entirely possible for "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to receive either fewer bytes than a single message,"},{"type":"text","text":" "},{"type":"text","text":"or multiple messages in one go. Rather than have the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" handle all of the complexity of this,"},{"type":"text","text":" "},{"type":"text","text":"the logic can be boiled down to a single choice: has the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" been able to move the state forward"},{"type":"text","text":" "},{"type":"text","text":"or not? If it has, rather than containing an internal loop it may simply return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":" in order to request that"},{"type":"text","text":" "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" be invoked again immediately. If it has not, it can return "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":" to ask to be left alone until more"},{"type":"text","text":" "},{"type":"text","text":"data has been returned from the network."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":". This will allow a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" implementation to ignore the awkward way data"},{"type":"text","text":" "},{"type":"text","text":"arrives from the network, and to just treat it as a series of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" calls."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is a cousin of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":". It is also called in a loop, but unlike with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" this loop will only ever"},{"type":"text","text":" "},{"type":"text","text":"occur once: when the "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" belonging to this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is about to become invalidated."},{"type":"text","text":" "},{"type":"text","text":"This invalidation happens in two situations: when EOF is received from the network, or when the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"is being removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". The distinction between these two states is captured by the value of"},{"type":"text","text":" "},{"type":"codeVoice","code":"seenEOF"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"In this condition, the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" must now produce any final messages it can with the bytes it has","type":"text"},{"text":" ","type":"text"},{"text":"available. In protocols where EOF is used as a message delimiter, having ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" called with ","type":"text"},{"code":"seenEOF == true","type":"codeVoice"},{"text":" ","type":"text"},{"text":"may produce further messages. In other cases, ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" may choose to deliver any buffered bytes as “leftovers”,","type":"text"},{"text":" ","type":"text"},{"text":"either in error messages or via ","type":"text"},{"code":"channelRead","type":"codeVoice"},{"text":". This can occur if, for example, a protocol upgrade is occurring.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is invoked in a loop. This allows the same simplification as "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" allows: when"},{"type":"text","text":" "},{"type":"text","text":"a message is completely parsed, the "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" function can return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":" and be re-invoked from the top,"},{"type":"text","text":" "},{"type":"text","text":"rather than containing an internal loop."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that the value of "},{"code":"seenEOF","type":"codeVoice"},{"type":"text","text":" may change between calls to "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":" in some rare situations."}],"type":"paragraph"},{"level":3,"anchor":"Implementers-Notes","type":"heading","text":"Implementers Notes"},{"inlineContent":[{"type":"text","text":"\/\/\/ "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":" will turn your "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" into a "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":". "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"also solves a couple of tricky issues for you. Most importantly, in a "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" you do "},{"inlineContent":[{"text":"not","type":"text"}],"type":"emphasis"},{"type":"text","text":" need to"},{"type":"text","text":" "},{"type":"text","text":"worry about re-entrancy. Your code owns the passed-in "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" for the duration of the "},{"code":"decode","type":"codeVoice"},{"type":"text","text":"\/"},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":" call and"},{"type":"text","text":" "},{"type":"text","text":"can modify it at will."}],"type":"paragraph"},{"inlineContent":[{"text":"If a custom frame decoder is required, then one needs to be careful when implementing","type":"text"},{"text":" ","type":"text"},{"text":"one with ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":". Ensure there are enough bytes in the buffer for a","type":"text"},{"text":" ","type":"text"},{"text":"complete frame by checking ","type":"text"},{"code":"buffer.readableBytes","type":"codeVoice"},{"text":". If there are not enough bytes","type":"text"},{"text":" ","type":"text"},{"text":"for a complete frame, return without modifying the reader index to allow more bytes to arrive.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To check for complete frames without modifying the reader index, use methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"You  ","type":"text"},{"inlineContent":[{"text":"MUST","type":"text"}],"type":"emphasis"},{"text":" use the reader index when using methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"For example calling ","type":"text"},{"code":"buffer.getInteger(at: 0)","type":"codeVoice"},{"text":" is assuming the frame starts at the beginning of the buffer, which","type":"text"},{"text":" ","type":"text"},{"text":"is not always the case. Use ","type":"text"},{"code":"buffer.getInteger(at: buffer.readerIndex)","type":"codeVoice"},{"text":" instead.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If you move the reader index forward, either manually or by using one of ","type":"text"},{"type":"codeVoice","code":"buffer.read*"},{"text":" methods, you must ensure","type":"text"},{"text":" ","type":"text"},{"text":"that you no longer need to see those bytes again as they will not be returned to you the next time ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" is","type":"text"},{"text":" ","type":"text"},{"text":"called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to","type":"text"},{"text":" ","type":"text"},{"text":"perform your read operations on.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" passed in as "},{"code":"buffer","type":"codeVoice"},{"type":"text","text":" is a slice of a larger buffer owned by the "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"implementation. Some aspects of this buffer are preserved across calls to "},{"code":"decode","type":"codeVoice"},{"type":"text","text":", meaning that any changes to"},{"type":"text","text":" "},{"type":"text","text":"those properties you make in your "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" method will be reflected in the next call to decode. In particular,"},{"type":"text","text":" "},{"type":"text","text":"moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,"},{"type":"text","text":" "},{"type":"text","text":"those bytes are considered “consumed” and will not be available in future calls to "},{"code":"decode","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Please note, however, that the numerical value of the "},{"code":"readerIndex","type":"codeVoice"},{"type":"text","text":" itself is not preserved, and may not be the same"},{"type":"text","text":" "},{"type":"text","text":"from one call to the next. Please do not rely on this numerical value: if you need"},{"type":"text","text":" "},{"type":"text","text":"to recall where a byte is relative to the "},{"code":"readerIndex","type":"codeVoice"},{"type":"text","text":", use an offset rather than an absolute value."}],"type":"paragraph"},{"level":3,"anchor":"Using-ByteToMessageDecoder","type":"heading","text":"Using ByteToMessageDecoder"},{"inlineContent":[{"type":"text","text":"To add a "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" to the "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" use"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"]}]}],"relationshipsSections":[{"title":"Inherited By","type":"inheritedBy","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder"]},{"title":"Conforming Types","type":"conformingTypes","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" to another message type."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder"},"topicSections":[{"title":"Associated Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)"]}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOJSONRPCFraming/ContentLengthHeaderFrameDecoder":{"title":"NIOJSONRPCFraming.ContentLengthHeaderFrameDecoder","type":"topic","role":"symbol","abstract":[{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","type":"reference","isActive":true},{"type":"text","text":" is responsible for parsing JSON-RPC wire protocol with ‘Content-Length’"},{"type":"text","text":" "},{"type":"text","text":"HTTP-like headers as used by for example by LSP (Language Server Protocol)."}],"url":"\/documentation\/nioextras\/niojsonrpcframing\/contentlengthheaderframedecoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","navigatorTitle":[{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageDecoder":{"type":"topic","title":"NIOSingleStepByteToMessageDecoder","url":"\/documentation\/niocore\/niosinglestepbytetomessagedecoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","navigatorTitle":[{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"kind":"symbol","role":"symbol","abstract":[{"text":"A simplified version of ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" that can generate zero or one messages for each invocation of ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Having ","type":"text"},{"code":"decode","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when returning. This allows for greatly simplified processing."}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decode(context:buffer:)":{"defaultImplementations":1,"role":"symbol","kind":"symbol","required":true,"abstract":[{"type":"text","text":"Decode from a "},{"code":"ByteBuffer","type":"codeVoice"},{"text":".","type":"text"}],"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decode","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore10ByteBufferV","text":"ByteBuffer"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore13DecodingStateO","text":"DecodingState"}],"title":"decode(context:buffer:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","url":"\/documentation\/niocore\/bytetomessagedecoder\/decode(context:buffer:)","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/SNIHandler":{"navigatorTitle":[{"text":"SNIHandler","kind":"identifier"}],"role":"symbol","kind":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","url":"\/documentation\/niotls\/snihandler","title":"SNIHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SNIHandler","kind":"identifier"}],"abstract":[{"text":"A channel handler that can be used to arbitrarily edit a channel","type":"text"},{"text":" ","type":"text"},{"text":"pipeline based on the hostname requested in the Server Name Indication","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"portion of the TLS Client Hello."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteObservingByteToMessageDecoder":{"kind":"symbol","abstract":[{"type":"text","text":"Some "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"s need to observe "},{"code":"write","type":"codeVoice"},{"type":"text","text":"s (which are outbound events). "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"s which"},{"type":"text","text":" "},{"type":"text","text":"implement the "},{"code":"WriteObservingByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" protocol will be notified about every outbound write."}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder","title":"WriteObservingByteToMessageDecoder","url":"\/documentation\/niocore\/writeobservingbytetomessagedecoder","navigatorTitle":[{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"url":"\/documentation\/niocore","title":"NIOCore","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","kind":"symbol","type":"topic","abstract":[],"role":"collection"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-1tkzf":{"required":true,"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","abstract":[{"text":"Decode from a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" when no more data is incoming and the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is about to leave"},{"type":"text","text":" "},{"type":"text","text":"the pipeline."}],"type":"topic","role":"symbol","url":"\/documentation\/niocore\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-1tkzf","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"decodeLast"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"text":"ByteBuffer","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore10ByteBufferV"},{"text":", ","kind":"text"},{"text":"seenEOF","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"DecodingState","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore13DecodingStateO"}],"title":"decodeLast(context:buffer:seenEOF:)","defaultImplementations":2},"doc://co.pointfree.VaporRouting/documentation/NIOWebSocket/WebSocketFrameDecoder":{"navigatorTitle":[{"text":"WebSocketFrameDecoder","kind":"identifier"}],"abstract":[{"text":"An inbound ","type":"text"},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that deserializes websocket frames into a structured","type":"text"},{"text":" ","type":"text"},{"text":"format for further processing.","type":"text"}],"url":"\/documentation\/niowebsocket\/websocketframedecoder","title":"WebSocketFrameDecoder","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketFrameDecoder","kind":"identifier"}],"kind":"symbol","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderRemoved(context:)-sa8l":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","kind":"symbol","required":true,"defaultImplementations":1,"role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"decoderRemoved","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":")","kind":"text"}],"url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderremoved(context:)-sa8l","title":"decoderRemoved(context:)","type":"topic","abstract":[{"text":"Called once this ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" is removed from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":".","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LineBasedFrameDecoder":{"abstract":[{"text":"A decoder that splits incoming ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":"s around line end","type":"text"},{"text":" ","type":"text"},{"text":"character(s) (","type":"text"},{"code":"'\\n'","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"'\\r\\n'","type":"codeVoice"},{"text":").","type":"text"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LineBasedFrameDecoder"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","title":"LineBasedFrameDecoder","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"LineBasedFrameDecoder"}],"url":"\/documentation\/nioextras\/linebasedframedecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","kind":"symbol","navigatorTitle":[{"text":"HTTPDecoder","kind":"identifier"}],"role":"symbol","title":"HTTPDecoder","type":"topic","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that parses HTTP\/1-style messages, converting them from"},{"type":"text","text":" "},{"type":"text","text":"unstructured bytes to a sequence of HTTP messages."}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPDecoder","kind":"identifier"}],"url":"\/documentation\/niohttp1\/httpdecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5fn2u":{"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"shouldReclaimBytes","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore10ByteBufferV","text":"ByteBuffer"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"abstract":[{"text":"Determine if the read bytes in the given ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" should be reclaimed and their associated memory freed.","type":"text"},{"text":" ","type":"text"},{"text":"Be aware that reclaiming memory may involve memory copies and so is not free.","type":"text"}],"required":true,"defaultImplementations":1,"url":"\/documentation\/niocore\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5fn2u","kind":"symbol","title":"shouldReclaimBytes(buffer:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderAdded(context:)-7trzq":{"role":"symbol","url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderadded(context:)-7trzq","type":"topic","title":"decoderAdded(context:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","abstract":[{"text":"Called when this ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" is added to the ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":".","type":"text"}],"kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decoderAdded","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":")","kind":"text"}],"defaultImplementations":1,"required":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder":{"role":"symbol","type":"topic","navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","url":"\/documentation\/niocore\/bytetomessagedecoder","title":"ByteToMessageDecoder","abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s decode bytes in a stream-like fashion from ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" to another message type.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldBasedFrameDecoder":{"url":"\/documentation\/nioextras\/lengthfieldbasedframedecoder","title":"LengthFieldBasedFrameDecoder","type":"topic","navigatorTitle":[{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"A decoder that splits the received "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" by the number of bytes specified in a fixed length header"},{"type":"text","text":" "},{"type":"text","text":"contained within the buffer."}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/InboundOut":{"fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"InboundOut"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut","url":"\/documentation\/niocore\/bytetomessagedecoder\/inboundout","title":"InboundOut","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"The type of the messages this "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" decodes to."}],"required":true,"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/FixedLengthFrameDecoder":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"kind":"symbol","abstract":[{"type":"text","text":"A decoder that splits the received "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" by a fixed number","type":"text"},{"text":" ","type":"text"},{"text":"of bytes. For example, if you received the following four fragmented packets:","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","role":"symbol","type":"topic","url":"\/documentation\/nioextras\/fixedlengthframedecoder","title":"FixedLengthFrameDecoder","navigatorTitle":[{"text":"FixedLengthFrameDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/wrapInboundOut(_:)":{"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"wrapInboundOut"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"InboundOut"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore6NIOAnyV","text":"NIOAny"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)","url":"\/documentation\/niocore\/bytetomessagedecoder\/wrapinboundout(_:)","title":"wrapInboundOut(_:)","kind":"symbol","type":"topic","abstract":[],"role":"symbol"}}}