{"variants":[{"paths":["\/documentation\/niocore\/channeloption"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"roleHeading":"Protocol","externalID":"s:7NIOCore13ChannelOptionP","navigatorTitle":[{"kind":"identifier","text":"ChannelOption"}],"modules":[{"name":"NIOCore"}],"symbolKind":"protocol","title":"ChannelOption","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"}]},"primaryContentSections":[{"declarations":[{"languages":["swift"],"platforms":["Linux"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"},{"kind":"text","text":" : "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore25NIOPreconcurrencySendableP","text":"NIOPreconcurrencySendable"},{"kind":"text","text":", "},{"kind":"typeIdentifier","preciseIdentifier":"s:SQ","text":"Equatable"}]}],"kind":"declarations"}],"kind":"symbol","topicSections":[{"title":"Associated Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption\/Value"]}],"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption","interfaceLanguage":"swift"},"abstract":[{"text":"A configuration option that can be set on a ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":" to configure different behaviour.","type":"text"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"sections":[],"relationshipsSections":[{"title":"Inherits From","kind":"relationships","type":"inheritsFrom","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","doc:\/\/co.pointfree.VaporRouting\/SQ"]},{"title":"Conforming Types","kind":"relationships","type":"conformingTypes","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AutoReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/BacklogOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ConnectTimeoutOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/MaxMessagesPerReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ReceivePacketInfo","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/RecvAllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/SocketOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteSpinOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption"]}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/MaxMessagesPerReadOption":{"type":"topic","title":"ChannelOptions.Types.MaxMessagesPerReadOption","url":"\/documentation\/niocore\/channeloptions\/types\/maxmessagesperreadoption","abstract":[{"code":"MaxMessagesPerReadOption","type":"codeVoice"},{"text":" allows users to configure the maximum number of read calls to the underlying transport are performed before wait again until","type":"text"},{"text":" ","type":"text"},{"text":"there is more to read and be notified.","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/MaxMessagesPerReadOption","navigatorTitle":[{"text":"MaxMessagesPerReadOption","kind":"identifier"}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MaxMessagesPerReadOption","kind":"identifier"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/DatagramVectorReadMessageCountOption":{"url":"\/documentation\/niocore\/channeloptions\/types\/datagramvectorreadmessagecountoption","kind":"symbol","type":"topic","title":"ChannelOptions.Types.DatagramVectorReadMessageCountOption","navigatorTitle":[{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"role":"symbol","abstract":[{"type":"codeVoice","code":"DatagramVectorReadMessageCountOption"},{"text":" allows users to configure the number of messages to attempt to read in a single syscall on a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"datagram "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOption/Value":{"url":"\/documentation\/niocore\/channeloption\/value","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"Value"}],"title":"Value","role":"symbol","abstract":[{"type":"text","text":"The type of the "},{"code":"ChannelOption","type":"codeVoice"},{"type":"text","text":"â€™s value."}],"kind":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption\/Value","required":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/WriteSpinOption":{"navigatorTitle":[{"kind":"identifier","text":"WriteSpinOption"}],"type":"topic","kind":"symbol","abstract":[{"type":"codeVoice","code":"WriteSpinOption"},{"text":" allows users to configure the number of repetitions of a only partially successful write call before considering the ","type":"text"},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."},{"type":"text","text":" "},{"type":"text","text":"Setting this option to "},{"code":"0","type":"codeVoice"},{"type":"text","text":" means that we only issue one write call and if that call does not write all the bytes,"},{"type":"text","text":" "},{"type":"text","text":"we consider the "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" not writable."}],"title":"ChannelOptions.Types.WriteSpinOption","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteSpinOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteSpinOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/writespinoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOption":{"url":"\/documentation\/niocore\/channeloption","kind":"symbol","type":"topic","title":"ChannelOption","navigatorTitle":[{"kind":"identifier","text":"ChannelOption"}],"role":"symbol","abstract":[{"text":"A configuration option that can be set on a ","type":"text"},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" to configure different behaviour."}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/WriteBufferWaterMarkOption":{"abstract":[{"code":"WriteBufferWaterMarkOption","type":"codeVoice"},{"text":" allows users to configure when a ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" should be marked as writable or not. Once the amount of bytes queued in a","type":"text"},{"text":" ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":"s outbound buffer is larger than ","type":"text"},{"code":"WriteBufferWaterMark.high","type":"codeVoice"},{"text":" the channel will be marked as non-writable and so","type":"text"},{"text":" ","type":"text"},{"code":"Channel.isWritable","type":"codeVoice"},{"text":" will return ","type":"text"},{"code":"false","type":"codeVoice"},{"text":". Once we were able to write some data out of the outbound buffer and the amount of bytes queued","type":"text"},{"text":" ","type":"text"},{"text":"falls below ","type":"text"},{"code":"WriteBufferWaterMark.low","type":"codeVoice"},{"text":" the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" will become writable again. Once this happens ","type":"text"},{"code":"Channel.writable","type":"codeVoice"},{"text":" will return","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":" again. These writability changes are also propagated through the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" and so can be intercepted via "},{"type":"codeVoice","code":"ChannelInboundHandler.channelWritabilityChanged"},{"type":"text","text":"."}],"kind":"symbol","type":"topic","title":"ChannelOptions.Types.WriteBufferWaterMarkOption","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteBufferWaterMarkOption","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"WriteBufferWaterMarkOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/writebufferwatermarkoption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteBufferWaterMarkOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/BacklogOption":{"type":"topic","role":"symbol","title":"ChannelOptions.Types.BacklogOption","kind":"symbol","abstract":[{"code":"BacklogOption","type":"codeVoice"},{"text":" allows users to configure the ","type":"text"},{"code":"backlog","type":"codeVoice"},{"text":" value as specified in ","type":"text"},{"code":"man 2 listen","type":"codeVoice"},{"text":". This is only useful for ","type":"text"},{"code":"ServerSocketChannel","type":"codeVoice"},{"text":"s.","type":"text"}],"navigatorTitle":[{"text":"BacklogOption","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BacklogOption","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/BacklogOption","url":"\/documentation\/niocore\/channeloptions\/types\/backlogoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ReceivePacketInfo":{"url":"\/documentation\/niocore\/channeloptions\/types\/receivepacketinfo","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReceivePacketInfo"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ReceivePacketInfo","kind":"symbol","title":"ChannelOptions.Types.ReceivePacketInfo","abstract":[{"type":"text","text":"When set to true IP level Packet Info information will be reported through "},{"code":"AddressedEnvelope.Metadata","type":"codeVoice"},{"type":"text","text":" for UDP packets."}],"navigatorTitle":[{"kind":"identifier","text":"ReceivePacketInfo"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AutoReadOption":{"role":"symbol","type":"topic","abstract":[{"code":"AutoReadOption","type":"codeVoice"},{"type":"text","text":" allows users to configure if a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" should automatically call "},{"code":"Channel.read","type":"codeVoice"},{"type":"text","text":" again once all data was read from the transport or"},{"text":" ","type":"text"},{"text":"if the user is responsible to call ","type":"text"},{"type":"codeVoice","code":"Channel.read"},{"text":" manually.","type":"text"}],"title":"ChannelOptions.Types.AutoReadOption","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AutoReadOption","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AutoReadOption","navigatorTitle":[{"text":"AutoReadOption","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niocore\/channeloptions\/types\/autoreadoption"},"doc://co.pointfree.VaporRouting/SQ":{"type":"unresolvable","identifier":"doc:\/\/co.pointfree.VaporRouting\/SQ","title":"Swift.Equatable"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AllowRemoteHalfClosureOption":{"role":"symbol","abstract":[{"code":"AllowRemoteHalfClosureOption","type":"codeVoice"},{"text":" allows users to configure whether the ","type":"text"},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will close itself when its remote"},{"type":"text","text":" "},{"type":"text","text":"peer shuts down its send stream, or whether it will remain open. If set to "},{"code":"false","type":"codeVoice"},{"text":" (the default), the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" ","type":"text"},{"text":"will be closed automatically if the remote peer shuts down its send stream. If set to true, the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" will","type":"text"},{"text":" ","type":"text"},{"text":"not be closed: instead, a ","type":"text"},{"code":"ChannelEvent.inboundClosed","type":"codeVoice"},{"type":"text","text":" user event will be sent on the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and no more data will be received."}],"kind":"symbol","url":"\/documentation\/niocore\/channeloptions\/types\/allowremotehalfclosureoption","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","navigatorTitle":[{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"title":"ChannelOptions.Types.AllowRemoteHalfClosureOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ExplicitCongestionNotificationsOption":{"navigatorTitle":[{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"title":"ChannelOptions.Types.ExplicitCongestionNotificationsOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"abstract":[{"type":"text","text":"When set to true IP level ECN information will be reported through "},{"type":"codeVoice","code":"AddressedEnvelope.Metadata"}],"url":"\/documentation\/niocore\/channeloptions\/types\/explicitcongestionnotificationsoption","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","kind":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ConnectTimeoutOption":{"navigatorTitle":[{"text":"ConnectTimeoutOption","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ConnectTimeoutOption","kind":"identifier"}],"role":"symbol","kind":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ConnectTimeoutOption","title":"ChannelOptions.Types.ConnectTimeoutOption","abstract":[{"code":"ConnectTimeoutOption","type":"codeVoice"},{"text":" allows users to configure the ","type":"text"},{"type":"codeVoice","code":"TimeAmount"},{"text":" after which a connect will fail if it was not established in the meantime. May be","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":", in which case the connection attempt will never time out.","type":"text"}],"url":"\/documentation\/niocore\/channeloptions\/types\/connecttimeoutoption"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP2/HTTP2StreamChannelOptions/Types/StreamIDOption":{"abstract":[{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption","isActive":true},{"type":"text","text":" allows users to query the stream ID for a given "},{"type":"codeVoice","code":"HTTP2StreamChannel"},{"type":"text","text":"."}],"url":"\/documentation\/niohttp2\/http2streamchanneloptions\/types\/streamidoption","title":"HTTP2StreamChannelOptions.Types.StreamIDOption","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"StreamIDOption","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption","kind":"symbol","navigatorTitle":[{"text":"StreamIDOption","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"url":"\/documentation\/niocore","title":"NIOCore","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","kind":"symbol","type":"topic","abstract":[],"role":"collection"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/SocketOption":{"type":"topic","title":"ChannelOptions.Types.SocketOption","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SocketOption","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niocore\/channeloptions\/types\/socketoption","abstract":[{"code":"SocketOption","type":"codeVoice"},{"text":" allows users to specify configuration settings that are directly applied to the underlying socket file descriptor.","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/SocketOption","role":"symbol","navigatorTitle":[{"text":"SocketOption","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/RecvAllocatorOption":{"title":"ChannelOptions.Types.RecvAllocatorOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"RecvAllocatorOption"}],"abstract":[{"type":"codeVoice","code":"RecvAllocatorOption"},{"type":"text","text":" allows users to specify the "},{"type":"codeVoice","code":"RecvByteBufferAllocator"},{"type":"text","text":" to use."}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"RecvAllocatorOption"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/RecvAllocatorOption","role":"symbol","url":"\/documentation\/niocore\/channeloptions\/types\/recvallocatoroption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPreconcurrencySendable":{"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","role":"symbol","title":"NIOPreconcurrencySendable","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"type":"topic","url":"\/documentation\/niocore\/niopreconcurrencysendable"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AllocatorOption":{"navigatorTitle":[{"kind":"identifier","text":"AllocatorOption"}],"title":"ChannelOptions.Types.AllocatorOption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllocatorOption","abstract":[{"type":"codeVoice","code":"AllocatorOption"},{"text":" allows to specify the ","type":"text"},{"code":"ByteBufferAllocator","type":"codeVoice"},{"text":" to use.","type":"text"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllocatorOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/allocatoroption","role":"symbol","kind":"symbol","type":"topic"}}}